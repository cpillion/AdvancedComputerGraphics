Final Project - Terrain Generation Using Modern OpenGL
Chris Pillion

SOURCE LANGUAGE:
  C++

COMPILE USING:
  qmake
  make

RUN USING:
  cpTerrainPro

ACTIONS:
  The camera can be moved in a simple first person manner
	W: Move Forward
	A: Move Backward
	Mouse Click and Drag: Look around/ Change Direction of movement
  All options are executed on the Qt Widget.
  The shader combobox enables the terrain fragment shader mode
  Map Size applies a scale factor to the xz axis of the map. 
  Peak size applies a scale factor to the height differences.
  Light Position changes the lighting from 0 to 360
  Animate Orbits the light and causes the snow to fall
  Reset to reset
  Quit to quit


PROJECT SUMMARY:
For my scene, I have decided to use the concepts learned in class to generate the basis of a complex terrain.  The idea is that many games and scenes use massive landscapes as the basis for their worlds, so being able to do this efficiently using modern graphics techniques would be a beneficial skill to learn. Because I planned to use modern OpenGL for the entire project, the first step was to properly convert a simple project from the Legacy OpenGL profile to the Core OpenGL profile.  On my 2012 Mac with a mediocre graphics card, this was a real pain, but eventually I was able to get a simple cube with colors, lighting, and textures up and running.  Many of the helper functions in the CUgl source files had to be modified to properly handle the execution of OpenGL 4.1 (the highest version of OGL that my graphics card, the Intel HD 4000, can handle).  To move to a more complex example, I decided to create a sphere using OGL4 as well, setting up colors and lighting on that as well.  These simple objects demonstrated the ability for my computer to accurately set up vertex buffer objects and vertex array objects, and properly assign the attribute data located in these storage items. The next step was the main focus of the project - generating the terrain using modern graphics techniques.  The idea was to use the tessellation shaders in order to generate a large number of traingles from a single OpenGL call.  The advantage of using the tessellation shaders would mean that we would dynamically determine the number of traingles (or scene fidelity) depending on whether the camera was near or far from a patricular area of the terrain. Without this dynamic behavior, rendering a large number of high fidelity triangles would mean a huge performance hit for areas of the scene that did not even matter to the viewer.  Because the tessellation shader was going to be used, the draw command necessitates the "patch" primitive. The first step was to generate verticies for patches and store them in a VBO and make a VAO.  To create a more dynamic and realistic environment, I used a height map texture to pull the pixel data and determine the height of each vertex. By knowing the size of the height map and the maximum tessellation level, we can subdivide the X and Z divisions for each vertex.  The idea is to create a large, flat, evenly spaced square grid of verticies in the XZ plane.  Each vertex is then passed to the vertex shader, which basically is just pass through.  The XZ vertex position is then passed to the tessellation control shader, which uses the Sphere method described in the NVIDIA Terrain Tessellation using DirectX 11 Whitepaper to determine the tessellation level. Each vertex is used to extrude a square patch of the size between each of the verticies. For each patch edge, the shader computes the edge length and then conceptually fits a sphere around it. The sphere is projected into screen-space and its screen-space diameter is used to compute the tessellation factor for the edge.  The method allows more details at closer range, while giving a performance boost by having less detail at further range. Another advantage of this method, when using uniform patches, is it is easier to control cracking in the terrain between patches.  Once the outer tessellation levels have been determined (4 different values for each side of the square patch), the inner tessellation level is determined by simply taking the max of the outer values. The tessellation evaluation shader is set to use quads (which is in line with our square patches) and uses non uniform spacing to space the newly generated vertcies.  The non uniform spacing is important because it allows the edges of patches to more easily avoid cracking.  The TES actually generates the new verticies for drawing.  It uses the height map to pull the R/G/B (any will work since its greyscale) value and displace the y position of the vertex appropriately. Onve the vertices are determined, the geometry shader is used to calculate the wireframe information, generating outlined triangle primitives for display.  This information is then passed to the fragment shader, which has several modes of operation, depending on the user input.  The first is a simple wireframe display, which colors the entire terrain green, then outlines the world in a red wireframe to hep visualize the generated triangles in the tessellation stages. The next mode is also wireframed, but applies a shaded gradient color to the terrain depending on the heights of the peaks.  The third mode applies texturing.  The textures are based off height and world normal. At first, I decided to apply th textures based off height, but the definite line between two textures was too obvious, so I did some research which pointed me in the direction of using the world normal to blend the textures instead. The next fragment shader uses the world normal (calculated in the TES) to do lighting on the scene. The last option is to apply both lighting and texutres to give the scene a more realistic visualization of what you might expect in a game. With the terrain now generated, I decided to create a more modern version of a skybox.  I created a crude skybox last year in the fixed pipeline, but with Modern OpenGL, I could create a better version.  Using a cube map and loading 6 different images into a texture, I was able to use shaders to texture and sample the cube map. This also allowed me to give a more massive feel to the scene.  To trick the viewer into thinking the scene is more massive, we draw the cube map first with the depth mask disabled.  The cube on which the texture is applied is actually very small (as seen in the orthographic projection) but because the depth mask is disabled, everything is drawn on top and it looks very far off.  We then disable the ability to approach the wall of the cube by removing the translation component from the modelview matrix.  This means the skybox will always have the camera centered in the middle of it. Lastly, to add a bit more to the scene, I used a particle system to have the scene display a snowing effect.  I generate the particle system and spread the particles over the viewing portion of the screen.  The particles do not snow over the entire terrain, but rather always move with the camera and it only snows in a small area in front of the camera - however, this makes it look like its snowing in the entire scene. While there is much more you could build upon in this scene, getting to this point has been a huge effort and I feel employs many of the techiques we learned in this class. All drawn objects use shaders with modern OpenGL and I have learned a great deal by working through this. 

NOTES:
The terrain is based off the Direct X Terrain Tesselation Whitepaper and used an example from kdab.com as a guideline.  
Configuring the Mac for OpenGL 4 was a real pain. 
Thanks for holding yet another great class!

